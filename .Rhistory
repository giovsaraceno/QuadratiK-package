library(pkgcheck)
pkgcheck("/Users/sarac/Documents/GitHub/QuadratiK-package")
pkgcheck("/Users/sarac/Documents/GitHub/QuadratiK-package/")
setwd("./..")
install.packages("pkgstats")
install.packages("pkgstats")
library (pkgstats)
Sys.setenv ("GITHUB_TOKEN" = "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")
library (pkgcheck)
mydir <- file.path (tempdir (), "srr-demo")
mydit
mydir
x <- pkgcheck("/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:\\Users\\sarac\\Documents\\GitHub/QuadratiK-package")
summary(x)
library(goodpractice)
g <- gp("C:\\Users\\sarac\\Documents\\GitHub/QuadratiK-package")
library(codemetar)
codemetar::write_codemeta("/Users/sarac/Documents/GitHub/QuadratiK-package")
print(x)
x <- pkgcheck("C:\\Users\\sarac\\Documents\\GitHub/QuadratiK-package")
summary(x)
usethis::use_agpl3_license()
setwd("QuadratiK-package/")
usethis::use_agpl3_license()
usethis::use_tidy_description()
x <- pkgcheck("C:\\Users\\sarac\\Documents\\GitHub/QuadratiK-package")
x <- pkgcheck("C:\\Users\\sarac\\Documents\\GitHub/QuadratiK-package")
usethis::use_gpl_license()
usethis::use_gpl_license()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
x <- pkgcheck("C:\\Users\\sarac\\Documents\\GitHub/QuadratiK-package")
usethis::use_github_links()
usethis::use_github_links(overwrite = TRUE)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
usethis::use_github_links(overwrite = TRUE)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
roxygen2::roxygenise()
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
summary(x)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenize()
devtools::document()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::build_manual()
roxygen2::roxygenize()
devtools::document()
devtools::document()
roxygen2::roxygenize()
devtools::load_all()
roxygen2::roxygenize()
devtools::document()
devtools::load_all()
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
summary(x)
covr::package_coverage()
usethis::use_appveyor()
usethis::use_github_action()
usethis::use_github_action()
usethis::use_github_action()
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
summary(x)
library (pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
usethis::use_github_action_check_full()
usethis::use_github_action("check-full")
usethis::use_github_links()
usethis::use_github_links(overwrite=TRUE)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
summary(x)
size <- 100
rho=0.8
mu = c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejvmf")
library(QuadratiK)
size <- 100
rho=0.8
mu = c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejvmf")
den <- dpkb(pkbd_dat$x, mu, rho)
expect_equal(dim(den),c(size,1))
library(testthat)
expect_equal(dim(den),c(size,1))
expect_false(any(den<0))
any(den<0)
#------------------------------------------------------
## Generating data point on the Sphere
## and computing the densities
size <- 100
d = 3
x_sp <- sample_hypersphere(d, size)
expect_equal(dim(den),c(size,d))
expect_equal(dim(x_sp),c(size,d))
x_sp/rowSums(x_sp^2)
rowSum(x_sp/rowSums(x_sp^2))
rowSums(x_sp/rowSums(x_sp^2))
rowSums(x_sp^2)
expect_true(any(rowSums(x_sp^2) ==1))
any(rowSums(x_sp^2) ==1)
roxygen2::roxygenize()
devtools::document()
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
summary(x)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/", goodpractice = FALSE)
summary(x)
library(covr)
report()
coverage <- package_coverage()
zero_coverage(coverage)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
size <- 100
groups<-c(rep(1, size), rep(2, size),rep(3,size))
rho=0.8
data1<-rpkb(size, c(1,0,0),rho,method='rejvmf')
library(QuadratiK)
size <- 100
groups<-c(rep(1, size), rep(2, size),rep(3,size))
rho=0.8
data1<-rpkb(size, c(1,0,0),rho,method='rejvmf')
data2<-rpkb(size, c(0,1,0),rho,method='rejacg')
data3<-rpkb(size, c(-1,0,0),rho,method='rejpsaw')
dat<-rbind(data1$x,data2$x, data3$x)ù
size <- 100
groups<-c(rep(1, size), rep(2, size),rep(3,size))
rho=0.8
data1<-rpkb(size, c(1,0,0),rho,method='rejvmf')
data2<-rpkb(size, c(0,1,0),rho,method='rejacg')
data3<-rpkb(size, c(-1,0,0),rho,method='rejpsaw')
dat<-rbind(data1$x,data2$x, data3$x)
# Assuming your function is named 'my_clustering_function'
# and it returns a list with a specific structure.
result <- pkbc(dat, nClust = 3)
expect_s4_class(result, "pkbc")
library(testthat)
expect_s4_class(result, "pkbc")
expect_true(all(result@res_k$postProbs >= 0 & result@res_k$postProbs <= 1))
expect_is(result@res_k$LogLik, "numeric")
result@res_k$LogLik
result@res_k$postProbs >= 0 & result@res_k$postProbs <= 1)
result@res_k$postProbs >= 0 & result@res_k$postProbs <= 1
result@res_k$postProbs >= 0 & result@res_k$postProbs <= 1
result@res_k[[3]]$LogLik
expect_is(result@res_k[[3]]$LogLik, "numeric")
class(result@res_k[[3]]$LogLik)
expect_type(result@res_k[[3]]$LogLik, "numeric")
type(result@res_k[[3]]$LogLik)
is.numeric(result@res_k[[3]]$LogLik)
typeof(result@res_k[[3]]$LogLik)
expect_type(result@res_k[[3]]$LogLik, "double")
result_loglik <- pkbc(dat, nClust = 3, stoppingRule = 'loglik')
result_max <- pkbc(dat, nClust = 3, stoppingRule = 'max')
expect_not_equal(result_loglik@res_k[[3]]$LogLik, result_max@res_k[[3]]$LogLik)
library(testthat)
expect_not_equal(result_loglik@res_k[[3]]$LogLik, result_max@res_k[[3]]$LogLik)
expect_error(pkbc(dat, nClust = 3, stoppingRule = 'prova'))
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package/")
summary(x)
print(x)
summary(x)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
expect_error(kb.test(x = matrix(rnorm(100), nrow = 10), h=0.5, b = -1), "b must be in (0,1]")
library(testthat)
expect_error(kb.test(x = matrix(rnorm(100), nrow = 10), h=0.5, b = -1), "b must be in (0,1]")
kb.test(x = matrix(rnorm(100), nrow = 10), h=0.5, b = -1)
library(QuadratiK)
expect_error(kb.test(x = matrix(rnorm(100), nrow = 10), h=0.5, b = -1), "b must be in (0,1]")
kb.test(x = matrix(rnorm(100), nrow = 10), h=0.5, b = -1)
expect_error(kb.test(x = matrix(rnorm(100), nrow = 10), h=0.5, b = -1), "b indicates the proportion used for the subsamples in the subsampling algoritm. It must be in (0,1]")
kb.test(x = matrix(rnorm(100), nrow = 10), h=0.5, b = -1)
"b indicates the proportion used for the subsamples in the subsampling algoritm. It must be in (0,1]"
expect_error(kb.test(x = seq(1,10), h=0.5),
"x must be a matrix or a data.frame")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
devtools::build_manual()
devtools::build_manual()
summary(x)
print(x)
summary(x)
usethis::use_github_action("check")
pkgcheck::use_github_action_pkgcheck()
rlang::last_trace()
pkgcheck::use_github_action_pkgcheck(overwrite = TRUE)
pkgcheck::use_github_action_pkgcheck(overwrite = TRUE)
usethis::use_github_action("test-coverage")
usethis::use_coverage()
usethis::use_github_action("test-coverage")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
pkgcheck::use_github_action_pkgcheck(overwrite = TRUE)
x = "not a matrix"
is.vector(x)
x
is.vector(x)
x <- matrix(x, ncol = 1)
x
is.numeric(x)
is.numeric(c(1,1))
library(testthat)
library(QuadratiK)
pk.test(x = list(rnorm(10),rnorm(10)), rho = 0.5)
list(rnorm(10),rnorm(10))
x=list(rnorm(10),rnorm(10))
is.vector(x)
a = c(1,2,3)
a
typeof(a)
class(a)
is.vector(a)
mode(a)
mode(x)
roxygen2::roxygenize()
devtools::document()
devtools::load_all()
devtools::build_manual()
pk.test(x = matrix(rnorm(100), ncol=2), rho = -0.1)
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = -0.1),
"rho must be in (0,1)")
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = -0.1),
"rho must be in (0,1)")
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = -0.1),
"rho must be in (0,1)", fixed=TRUE)
roxygen2::roxygenize()
library(pkgcheck)
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
print(x)
seq_len(2)
seq_len(0)
roxygen2::roxygenize()
devtools::document()
devtools::load_all()
devtools::document()
devtools::build_vignettes()
.Last.value
.Last.error
library(QuadratiK)
head(wireless)
wire <- wireless[,-8]
labels <- wireless[,8]
wire_norm <- wire/sqrt(rowSums(wire^2))
set.seed(2468)
res_pk <- pkbc(as.matrix(wire_norm),3:6)
roxygen2::roxygenize()
devtools::build_vignettes()
roxygen2::roxygenize()
library(testthat)
kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5,
method = "invalid_method")
expect_error(kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5,
method = "invalid_method"),
"method must be one of 'bootstrap', 'permutation' or
'subsampling'", fixed=TRUE)
kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5,
method = "invalid_method")
expect_error(kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5,
method = "invalid_method"),
"method must be one of 'bootstrap', 'permutation' or
'subsampling'", fixed=TRUE)
expect_error(kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5,
method = "invalid_method"),
"method must be one of 'bootstrap', 'permutation' or
'subsampling'", fixed=TRUE)
expect_error(kb.test(x = matrix(rnorm(100), ncol= 2),
y = matrix(rnorm(100), ncol= 2), h=0.5,
alternative = "invalid"),
"One of alternatives: 'location', 'scale' or 'skewness'", fixed=TRUE)
expect_error(kb.test(x = matrix(rnorm(100), ncol= 2),
y = matrix(rnorm(100), ncol= 2), h=0.5,
alternative = "invalid"),
"The algorithm for selecting the value of h can be performed
with respect to the following families of alternatives:
'location', 'scale' or 'skewness'", fixed=TRUE)
# Test 5: Correct handling of vector x input
test_that("Handle vector x input correctly", {
result <- kb.test(x = rnorm(10), h=0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance Normality test")
})
# Test 6: Testing main functionality: two-sample test
test_that("Functionality with valid inputs", {
x <- matrix(rnorm(100), ncol = 2)
y <- matrix(rnorm(100), ncol = 2)
result <- kb.test(x, y, h=0.5, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance two-sample test")
expect_true(is.numeric(result@Dn))
expect_false(result@H0)
})
# Test 7: Testing main functionality: k-sample test
test_that("Functionality with valid inputs", {
x <- matrix(rnorm(100), ncol = 2)
y <- rep(c(1,2), each=25)
result <- kb.test(x, y, h=0.5, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance k-sample test")
expect_true(is.numeric(result@Dn))
expect_false(result@H0)
})
# Test 1: Verify Error on Invalid nClust
test_that("Error is thrown for invalid nClust", {
expect_error(pkbc(dat, nClust = 0), "nClust must be greater than 0")
})
pkbc(dat, nClust = 0)
# Test 1: Verify Error on Invalid nClust
test_that("Error is thrown for invalid nClust", {
dat <- matrix(rnorm(100),ncol=2)
expect_error(pkbc(dat, nClust = 0), "nClust must be greater than 0")
})
dat <- matrix(rnorm(100),ncol=2)
pkbc(dat, nClust = 0)
expect_error(pkbc(dat, nClust = 0), "Values in the input parameter nClust must be
greater than 0")
# Test 1: Verify Error on Invalid nClust
test_that("Error is thrown for invalid nClust", {
dat <- matrix(rnorm(100),ncol=2)
expect_error(pkbc(dat, nClust = 0), "Values in the input parameter nClust must be
greater than 0")
})
# Test 2: Test for valid input
test_that("Function works for valid input", {
result <- pkbc(dat, nClust = 3)
expect_s4_class(result, "pkbc")
expect_true(all(result@res_k$postProbs >= 0 & result@res_k$postProbs <= 1))
expect_type(result@res_k[[3]]$LogLik, "double")
})
# Test 3: Test for stopping rule
test_that("Function respects the stopping rule", {
result_loglik <- pkbc(dat, nClust = 3, stoppingRule = 'loglik')
result_max <- pkbc(dat, nClust = 3, stoppingRule = 'max')
expect_true(class(result_loglik)== "pkbc")
expect_true(class(result_max)== "pkbc")
expect_error(pkbc(dat, nClust = 3, stoppingRule = 'prova'))
})
test_that("Clustering algorithm works", {
pkbd_res<- pkbc(dat, 3)
expect_true(class(pkbd_res)== "pkbc")
expect_type(pkbd_res@res_k, "list")
})
kb.test(x = matrix(rnorm(100), ncol= 2),
y = matrix(rnorm(100), ncol= 2), h=0.5,
alternative = "invalid")
# Test 3: Error on Invalid alternative Input
test_that("Error on invalid alternative input", {
expect_error(kb.test(x = matrix(rnorm(100), ncol= 2),
y = matrix(rnorm(100), ncol= 2), h=0.5,
alternative = "invalid"),
"The algorithm for selecting the value of h can be performed
with respect to the following families of alternatives:
'location', 'scale' or 'skewness'", fixed=TRUE)
})
kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5, b = 10)
# Test 2: Verify Error on Invalid b Input
test_that("Error on invalid b input", {
expect_error(kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5, b = 10),
"b indicates the proportion used for the subsamples in the
subsampling algoritm. It must be in (0,1].", fixed=TRUE)
})
kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5,
method = "invalid_method")
# Test 1: Verify Error on Invalid Method Input
test_that("Error on invalid method input", {
expect_error(kb.test(x = matrix(rnorm(100), ncol = 2), h=0.5,
method = "invalid_method"),
"method must be one of 'bootstrap', 'permutation' or
'subsampling'", fixed=TRUE)
})
roxygen2::roxygenize()
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
print(x)
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
print(x)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
result_loglik <- pkbc(dat, nClust = 3, stoppingRule = 'loglik')
library(QuadratiK)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
result_loglik <- pkbc(dat, nClust = 3, stoppingRule = 'loglik')
result_max <- pkbc(dat, nClust = 3, stoppingRule = 'max')
val2 <- validation(pkbc(dat, c(2,3,4)), true_label = y, elbow.plot = TRUE)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
y <- rep(c(1,2),each=25)
val1 <- validation(pkbc(dat, 2), true_label = NULL, elbow.plot = FALSE)
val2 <- validation(pkbc(dat, c(2,3,4)), true_label = y, elbow.plot = TRUE)
librarù
library(testthat)
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2), matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested
number of clusters")
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
devtools::document()
summary_stat(pkbd_res, 4)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2), matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested
number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
res1$metrics
expect_equal(length(res1$metrics), 2)
# Test 1: Test for summary_stat
test_that("summary_stat test", {
# dimension = 2
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2), matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested
number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 2)
expect_equal(length(res2$metrics), 2)
# dimension = 3
dat<-rbind(matrix(rnorm(60),ncol=3), matrix(rnorm(60,4),ncol=3), matrix(rnorm(60,2),ncol=3))
y <- rep(c(1,2,3),each=20)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 3)
expect_equal(length(res2$metrics), 3)
# dimension = 4
dat<-rbind(matrix(rnorm(60),ncol=4), matrix(rnorm(60,4),ncol=4), matrix(rnorm(60,2),ncol=4))
y <- rep(c(1,2,3),each=15)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 4)
expect_equal(length(res2$metrics), 4)
})
roxygen2::roxygenize()
devtools::document()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::document()
